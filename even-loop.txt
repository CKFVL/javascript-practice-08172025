https://www.youtube.com/watch?v=eiC58R16hb8
https://www.jsv9000.app/ - for analyzing the interactive visualization
########################
browser APIs:
Macro task:
    setTimeout
    setInterval;
    fetch

Micro task (runs high priority tasks)
    Promise
########################
call stack -> Microtask queue -> Macrotask queue
########################
function a(){
    console.log("A")
}
setTimeout(() => console.log("B"), 0)
a()
console.log("C")
Promise.resolve().then(() => console.log("D"))

Step-by-step execution
1Ô∏è‚É£ Synchronous code (Call Stack)

JS runs all synchronous code top to bottom first.

setTimeout(...)   // schedules a macrotask ‚Üí B
a()               // logs "A"
console.log("C")  // logs "C"
Promise.resolve() // schedules a microtask ‚Üí D

Output so far:
A
C

2Ô∏è‚É£ Microtask Queue (highest priority)
After the call stack becomes empty, JS runs ALL microtasks before touching macrotasks.

Promise.then ‚Üí console.log("D")

Output:
D

3Ô∏è‚É£ Macrotask Queue (Task Queue)
Now JS takes the next macrotask.

setTimeout ‚Üí console.log("B")
Output:
B

‚úÖ Final Output Order
A
C
D
B

Why setTimeout(..., 0) is NOT immediate ‚ùó
0 means minimum delay, not instant

It still goes to the macrotask queue
Microtasks always run before macrotasks

Execution model summary üß†
Call Stack (sync)
   ‚Üì
Microtask Queue (Promises, queueMicrotask)
   ‚Üì
Macrotask Queue (setTimeout, setInterval, I/O)

One-liner rule to remember
Promises beat timeouts. Always.

########################
console.log(1)
setTimeout(() => {
    console.log(2)
}, 0)
Promise.resolve(console.log(3))
console.log(4)

Output: 1, 3, 4, 2

‚ö†Ô∏è Important gotcha
console.log(3) is executed immediately
Its return value is undefined
So this becomes:
Promise.resolve(undefined) // This does NOT create a microtask

‚û°Ô∏è prints 3 right now, synchronously
‚û°Ô∏è No .then() ‚Üí no microtask is scheduled

‚úÖ This DOES
Promise.resolve().then(() => console.log(3))
or
Promise.resolve(3).then(console.log)

*** Rule to remember:
Arguments to functions are evaluated immediately
Only .then(), await, or queueMicrotask() schedule microtasks.

Macrotask Queue (setTimeout):
setTimeout(() => {
    console.log(2)
}, 0)
‚û°Ô∏è Runs after call stack + microtasks
‚û°Ô∏è prints 2
