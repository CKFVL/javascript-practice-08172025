https://www.youtube.com/watch?v=eiC58R16hb8

---
function a(){
    console.log("A")
}
setTimeout(() => console.log("B"), 0)
a()
console.log("C")
Promise.resolve().then(() => console.log("D"))

Step-by-step execution
1Ô∏è‚É£ Synchronous code (Call Stack)

JS runs all synchronous code top to bottom first.

setTimeout(...)   // schedules a macrotask ‚Üí B
a()               // logs "A"
console.log("C")  // logs "C"
Promise.resolve() // schedules a microtask ‚Üí D

Output so far:
A
C

2Ô∏è‚É£ Microtask Queue (highest priority)
After the call stack becomes empty, JS runs ALL microtasks before touching macrotasks.

Promise.then ‚Üí console.log("D")

Output:
D

3Ô∏è‚É£ Macrotask Queue (Task Queue)
Now JS takes the next macrotask.

setTimeout ‚Üí console.log("B")
Output:
B

‚úÖ Final Output Order
A
C
D
B

Why setTimeout(..., 0) is NOT immediate ‚ùó
0 means minimum delay, not instant

It still goes to the macrotask queue
Microtasks always run before macrotasks

Execution model summary üß†
Call Stack (sync)
   ‚Üì
Microtask Queue (Promises, queueMicrotask)
   ‚Üì
Macrotask Queue (setTimeout, setInterval, I/O)

One-liner rule to remember
Promises beat timeouts. Always.
