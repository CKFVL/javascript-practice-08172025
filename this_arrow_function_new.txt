âœ… Key takeaway for arrow functions:
Arrow functions donâ€™t have their own this.
In arrow functions, this is lexical â€” taken from the surrounding scope.
(Arrow functions capture this from their parent scope)
Arrow functions are the rebel children â€” they ignore `this` rule and just take this from where they were created/written

---
âœ… Key takeaway for regular functions:
this is not lexical in normal functions â€” itâ€™s dynamic.

Hereâ€™s the one-line trick to instantly figure out this in any *** regular function call *** :
*** Look to the left of the dot when the function is called â€” thatâ€™s your this.
*** The object that actually calls the function decides what this will be inside that function.
*** If thereâ€™s no dot, this is the global object (or undefined in strict mode).
ğŸ“Œ Rule of thumb:
In regular functions, this is not fixed â€” itâ€™s assigned at the moment the function is called, and the â€œassignerâ€ is whoever is doing the calling.

###############################
âœ… Example 1: Arrow function inside object â†’ does NOT bind this
const user = {
  name: "Pavan",
  getName: () => {
    console.log(this.name);
  }
};

user.getName(); // undefined
Why undefined?
this inside arrow function does NOT refer to user.
It refers to the outer scope (global), where name does not exist.





###############################

function Timer() { 
this.seconds = 0; 
setInterval(() => { this.seconds++; console.log(this.seconds); }, 1000); } 

new Timer();

âœ… Code
function Timer() {
  this.seconds = 0;

  setInterval(() => {
    this.seconds++;
    console.log(this.seconds);
  }, 1000);
}

new Timer();

âœ”ï¸ First Key Point â€” Constructor call with new

When you call:

new Timer();


JavaScript does the following internally:

Creates a new empty object
â†’ {}

Sets this inside Timer() to that new object
â†’ this = {} (the new Timer instance)

It adds the property:

this.seconds = 0;


So now the object is:

{ seconds: 0 }

âœ”ï¸ Second Key Point â€” Arrow function behavior

Arrow functions do NOT have their own this.

So in:

setInterval(() => {
  this.seconds++;
  console.log(this.seconds);
}, 1000);


The arrow function borrows this from the surrounding scope.
ğŸ‘‰ The surrounding scope = the Timer constructor function.
And inside the constructor, this refers to the Timer instance.
So inside the arrow function:

this.seconds means:
the seconds property of the Timer instance

This is why the seconds update works correctly.
âœ”ï¸ Third Key Point â€” What if you used a regular function?

If you wrote:

setInterval(function() {
  this.seconds++;
  console.log(this.seconds);
}, 1000);


Here, the callback is a regular function.
Regular functions get this from how they are called, not where they are created.
And setInterval() calls the callback without an object:
callback(); // no object to the left of .


So in a regular function:
this becomes the global object (window in browsers)
or undefined (in strict mode)

Thus:
this.seconds++   // âŒ would fail or modify window.seconds

âœ”ï¸ Conclusion
Why does the arrow function work?
Because:
âœ” Arrow functions capture this from their parent scope
âœ” Parent scope = Timer constructor
âœ” Timer constructor's this = Timer instance

So the arrow functionâ€™s this â†’ the Timer object.
ğŸ¯ THE SIMPLEST SUMMARY
Arrow functions donâ€™t have their own this.
They use the this of the place where they were created.

Here, the arrow function is created inside the constructor, so it inherits the constructorâ€™s this â†’ the Timer instance.
