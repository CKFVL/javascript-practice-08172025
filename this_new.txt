Refer lexicalBinding.txt
---
`this` doesn't always mean the current object- it's actually determined by how a function is called, not where it's written.
✅ Key takeaway:
this is not lexical in normal functions — it’s dynamic.
In arrow functions, this is lexical — taken from the surrounding scope.

Here’s the one-line trick to instantly figure out this in any *** regular function call *** :
*** Look to the left of the dot when the function is called — that’s your this.
*** If there’s no dot, this is the global object (or undefined in strict mode).

1️⃣ Global Context
Outside of any function:
console.log(this); 

In a browser: this → window object.
In Node.js: this → {} (empty object in modules).
---
2️⃣ Inside a Regular Function
The value of this depends on the caller:
function showThis() {
  console.log(this);
}
// Look to the left of the dot when the function is called 
showThis();         // In non-strict mode: global object (window)
                    // In strict mode: undefined
---
3️⃣ Inside an Object Method
When called as an object’s property, this → that object.
const person = {
  name: "Pavan",
  greet() {
    console.log(this.name);
  }
};
// Look to the left of the dot when the function is called 
person.greet(); // "Pavan"
---
Event Handlers
this is usually set to the element that received the event.
document.getElementById("btn").addEventListener("click", function () {
  console.log(this); // The <button> element
});
---
Explicit Binding
We can control this with:
.call(thisArg, ...args)
.apply(thisArg, [args])
.bind(thisArg)

function greet() {
  console.log(this.name);
}

const obj = { name: "Pavan" };
greet.call(obj);  // "Pavan"
greet.apply(obj); // "Pavan"

const bound = greet.bind(obj);
bound();          // "Pavan"
---
