encapusalation is the process of bundling the data(properties) and functions(methods) into a single unit and restricting direct access to some object's components.
in simpler words, it's about hiding internal details and exposing what is required/necessary to protect the data.

Why Encapsulation?
Data hiding: Prevent outside code from accidentally (or intentionally) messing with internal data.
Controlled access: You decide what can be read/changed and how.
Maintainability: You can change internal implementation without affecting other parts of code.
Security: Prevents unintended side effects.

Here:
balance is private because it’s inside a closure.
Outside code can’t modify it directly, only via methods (deposit, withdraw).

function bankAccount(initialBalance){
  let balance=initialBalance;
  
 this.deposit=function(amount){
    balance+=amount;
    console.log(`current balance: ${balance}`)
  }
  
  
  this.withdraw=function(amount){
    if(amount>0 && balance>amount){
        balance=balance-amount;  
        console.log(`withdrew: ${amount}` )
    }else{
      console.log(`insufficient funds`)
    }
  }
  
  this.getBalance=function getBalance(){
    return balance;
  }
  
}

const bankacc=new bankAccount(100);
console.log(bankacc.getBalance())

bankacc.withdraw(1000)

bankacc.deposit(999)

bankacc.withdraw(991)

console.log(bankacc.getBalance())

###################################
2. Using ES6 class with # Private Fields
class BankAccount {
    #balance; // private field

    constructor(initialBalance) {
        this.#balance = initialBalance;
    }

    deposit(amount) {
        if (amount > 0) this.#balance += amount;
    }

    withdraw(amount) {
        if (amount > 0 && amount <= this.#balance) {
            this.#balance -= amount;
        } else {
            console.log("Insufficient funds");
        }
    }

    getBalance() {
        return this.#balance;
    }
}

const account = new BankAccount(100);
account.deposit(50);
account.withdraw(30);
console.log(account.getBalance()); // 120

// ❌ Can't access private field
console.log(account.#balance); // SyntaxError
###################################
3. Encapsulation via JavaScript Modules

When you put code inside a module (ES Modules or CommonJS), anything you don’t export stays private inside that file.
This way:
  Internal helper functions and variables stay hidden.
  Only a controlled API is exposed.

Example — ES Modules (import / export)
bankAccount.js

// 🔒 Private variables and functions (not exported)
let accounts = new Map();

function generateAccountId() {
    return `ACC${Math.floor(Math.random() * 10000)}`;
}

// ✅ Public API
export function createAccount(initialBalance) {
    const id = generateAccountId();
    accounts.set(id, initialBalance);
    return id;
}

export function deposit(id, amount) {
    if (accounts.has(id)) {
        accounts.set(id, accounts.get(id) + amount);
    }
}

export function getBalance(id) {
    return accounts.get(id) ?? null;
}
###################################
Example — ES Modules (import / export)

bankAccount.js
// 🔒 Private variables and functions (not exported)
let accounts = new Map();

function generateAccountId() {
    return `ACC${Math.floor(Math.random() * 10000)}`;
}

// ✅ Public API
export function createAccount(initialBalance) {
    const id = generateAccountId();
    accounts.set(id, initialBalance);
    return id;
}

export function deposit(id, amount) {
    if (accounts.has(id)) {
        accounts.set(id, accounts.get(id) + amount);
    }
}

export function getBalance(id) {
    return accounts.get(id) ?? null;
}

app.js
import { createAccount, deposit, getBalance } from './bankAccount.js';

const id = createAccount(100);
deposit(id, 50);
console.log(getBalance(id)); // 150

// ❌ Can't directly access accounts or generateAccountId()
// console.log(accounts); // ReferenceError

##########################
In real-world enterprise apps, encapsulation via modules is the most common — closures are used for small utilities, and #privateFields in classes are used for domain models.
##########################

Here’s your side-by-side comparison of encapsulation in JavaScript using Closures, Classes with # fields, and Modules:

| Feature / Aspect                | **Closures**                                                     | **Classes with `#` Private Fields**                        | **Modules**                                                          |
| ------------------------------- | ---------------------------------------------------------------- | ---------------------------------------------------------- | -------------------------------------------------------------------- |
| **How privacy is achieved**     | Variables live in a function’s scope and are not returned.       | `#` prefix creates truly private fields (ES2022).          | Anything not `export`ed stays private to the file.                   |
| **Where data is stored**        | Inside the closure’s lexical environment.                        | Inside the instance, but accessible only to class methods. | Inside the module scope (file-level).                                |
| **Syntax complexity**           | Simple but can get verbose with many functions.                  | Clean and modern, but requires newer JS runtime support.   | Simple for large projects, natural with ES Modules.                  |
| **Access control**              | Only functions inside closure can read/write variables.          | Only methods inside the same class can access `#fields`.   | Only exported functions/objects are public.                          |
| **Example use case**            | Small, self-contained objects/functions.                         | Class-based OOP models (bank account, user profile).       | Large applications with multiple files/modules.                      |
| **Can be broken from outside?** | Not directly, unless you expose a reference to a private object. | No (true privacy enforced by language).                    | No (unless someone edits the module file itself).                    |
| **Browser / Node support**      | Works everywhere (oldest technique).                             | Modern browsers & Node 12+ for `#privateFields`.           | ES Modules: Modern browsers & Node 14+. CommonJS: All Node versions. |
