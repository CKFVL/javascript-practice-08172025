*** only functions create scope, not objects.
function () { } → creates new this
() => { } → does NOT create new this
{ } object literal → does NOT create new this
example:
let length = 10;
const object = {
  length: 5,
  log: () => {
    console.log(this.length);
  },
};

object.log(); // output: 10
########################

const tagvideo = {
    title: 'tag',
    tags: ['a', 'b', 'c', 'd'],
    showTags() {
        //this.tags.forEach(function (tag) {
        //console.log(this.title, tag)// title will be undefined because function is like regular function, not tagvideo's method
        // this refers to global object
        //});
        // instead pass this as an object to forEach function 
        this.tags.forEach(function (tag) {
            console.log(this.title, tag)
        }, this);
    }
};

tagvideo.showTags()
###########################
Is the function an arrow function?
  │
  ├── YES → Inherit `this` from surrounding scope
  │             ▲
  │             │
  │    Closest enclosing scope:
  │      ├─ Regular function? → Use its `this`
  │      ├─ Another arrow? → Keep climbing outward
  │      └─ Global/module? → Use global/module `this`
  │
  └── NO (Regular function)
        │
        ├── Called with `new`? → `this` = New object
        │
        ├── Called with .call/.apply/.bind?
        │        → `this` = First argument passed
        │
        ├── Called as obj.method()? → `this` = Object left of dot
        │
        └── None of the above?
                 → `this` = Global object (non-strict) or undefined (strict)
Example:
------
  const obj={
  name:'pavan',
  log: ()=>{
    console.log(this.name)
  }
}

obj.log()

const obj2={
  name:'pavan',
  log: function(){
    console.log(this.name)
  }
}

obj2.log()

const obj3={
  name:'pavan',
  log: function(){
    console.log('function ',this.name)
    setTimeout(()=>{
      console.log('arrow timeout',this.name)
    }, 1000);
  }
}

obj3.log()
