A callback function in JavaScript is simply a function that is passed as an argument to another function and is intended to be executed later (either synchronously or asynchronously).
It’s called a “callback” because the receiving function calls it back at the appropriate time.

Why use callbacks?
To make functions reusable and customizable.
To handle asynchronous tasks (like fetching data, reading files, timers, etc.).
To separate logic from execution flow.

Synchronous callback:
----------------------
function multiply(a,b){
  console.log(`performing multiply for a, b =`+a+`, `+ b)
  return a*b;
}

function sum(a,b){
  console.log('performing sum')
  return a+b;
}

function subtraction(a,b){
  console.log('performing subtraction')
  return a-b;
}

const calc=function(a, b, callback){
  console.log(callback(a,b))
}

calc(2,3,multiply)
calc(2,3, subtraction)

Asynchronous callback:
----------------------
console.log('start')

setTimeout(function(){
  console.log('called after 2 min')
},1000)

console.log('end')

// example of callback function in javascript library
// The sort, map, forEach, filter, reduce methods in Array calls the callbackfn function one time for each element in the array.
let cars=[{type:'sedan', brand: 'toyota', year:'1984', available:2},
{type:'hatchback', brand: 'volvo', year:'1985', available:1},
{type:'suv', brand: 'infinity', year:'1995', available:5},
{type:'mini', brand: 'cooper', year:'2000', available:100}
]

let sortByYear=cars.sort(function(a, b){
  return a.year-b.year
})

sortByYear.forEach(function(car){
  console.log(car.year)
})

cars.forEach(function(car, index){
  console.log(index, car)
})

let totalAvailableCars=0;
cars.map(function(car, index){
  totalAvailableCars+=car.available
})

console.log(totalAvailableCars)


##############################
Local class: Use it if you need to create more than one instance of a class, access its constructor, or introduce a new, named type
 (because, for example, you need to invoke additional methods later).

 Anonymous class: Use it if you need to declare fields or implement methods or additional methods at runtime.
 *** declare and instantiate class at same time.

 an object is created for both local and anonymous types. The difference however is you can't reuse the anonymous class

 Lambda expression: Use it if you are encapsulating a single unit of behavior that you want to pass to other code.
 For example, you would use a lambda expression if you want a certain action performed on each element of a collection, when a process is completed,
 or when a process encounters an error.
 Use it if you need a simple instance of a functional interface and none of the preceding criteria apply
 (for example, you do not need a constructor, a named type, fields, or additional methods).

