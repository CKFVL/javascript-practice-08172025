Refer lexicalBinding.txt
---
reference: https://chatgpt.com/g/g-p-6932cd86cb2481918db0c75be634dfea-javascript/c/689c92ef-918c-8323-ab81-4d4b4d54cab4
https://chatgpt.com/g/g-p-6932cd86cb2481918db0c75be634dfea-javascript/c/69339e84-f34c-8322-ae99-b4b917823954
`this` doesn't always mean the current object- it's actually determined by how a function is called, not where it's written.
‚úÖ Key takeaway for regular functions:
this is not lexical in normal functions ‚Äî it‚Äôs dynamic.

Here‚Äôs the one-line trick to instantly figure out this in any *** regular function call *** :
*** Look to the left of the dot when the function is called ‚Äî that‚Äôs your this.
*** The object that actually calls the function decides what this will be inside that function.
*** If there‚Äôs no dot, this is the global object (or undefined in strict mode).
üìå Rule of thumb:
In regular functions, this is not fixed ‚Äî it‚Äôs assigned at the moment the function is called, and the ‚Äúassigner‚Äù is whoever is doing the calling.


‚úÖ Key takeaway for arrow functions:
Arrow functions don‚Äôt have their own this.
In arrow functions, this is lexical ‚Äî taken from the surrounding scope.
(Arrow functions capture this from their parent scope)
Arrow functions are the rebel children ‚Äî they ignore this rule and just take this from where they were created/written

---
1Ô∏è‚É£ Global Context
Outside of any function:
console.log(this); 

In a browser: this ‚Üí window object.
In Node.js: this ‚Üí {} (empty object in modules).
---
2Ô∏è‚É£ Inside a Regular Function
The value of this depends on the caller:
function showThis() {
  console.log(this);
}
// Look to the left of the dot when the function is called 
showThis();         // In non-strict mode: global object (window)
                    // In strict mode: undefined
---
3Ô∏è‚É£ Inside an Object Method
When called as an object‚Äôs property, this ‚Üí that object.
const person = {
  name: "Pavan",
  greet() {
    console.log(this.name);
  }
};
// Look to the left of the dot when the function is called 
person.greet(); // "Pavan"

Example 1 ‚Äî Same function, different callers
function showThis() {
  console.log(this);
}
const obj1 = { name: "Obj1", show: showThis };
const obj2 = { name: "Obj2", show: showThis };

// Calling through obj1
obj1.show(); // `this` is obj1 ‚Üí { name: "Obj1", show: f }

// Calling through obj2
obj2.show(); // `this` is obj2 ‚Üí { name: "Obj2", show: f }

// Calling directly
showThis(); // `this` is window (or undefined in strict mode)
üí° The same showThis function is reused, but the value of this changes based on who calls it.

Example 2 ‚Äî Losing the caller
const person = {
  name: "Pavan",
  greet() {
    console.log(this.name);
  }
};
person.greet(); // "Pavan"  (caller is `person`)
const fn = person.greet;
fn(); // undefined or error (caller is now global object)
Here, when fn() runs, it‚Äôs no longer called through person, so this loses its link to that object.
---
Event Handlers
this is usually set to the element that received the event.
document.getElementById("btn").addEventListener("click", function () {
  console.log(this); // The <button> element
});
---
Explicit Binding
We can control this with:
.call(thisArg, ...args)
.apply(thisArg, [args])
.bind(thisArg)

function greet() {
  console.log(this.name);
}

const obj = { name: "Pavan" };
greet.call(obj);  // "Pavan"
greet.apply(obj); // "Pavan"

const bound = greet.bind(obj);
bound();          // "Pavan"
---
More examples:
1. Dot present ‚Üí this is the object before the dot
const car = {
  brand: "Tesla",
  start: function() {
    console.log(this.brand);
  }
};

car.start(); // "Tesla"  ‚Üê left of dot = car

2. No dot ‚Üí global object (or undefined in strict mode)
function showBrand() {
  console.log(this.brand);
}
showBrand(); // undefined (strict mode) OR window.brand (non-strict)

3. Chained dots ‚Üí the immediate left counts
const garage = {
  car: {
    brand: "BMW",
    start: function() {
      console.log(this.brand);
    }
  }
};

garage.car.start(); // "BMW" ‚Üê left of dot is `garage.car`

4. Call stored in a variable ‚Üí loses caller info
const bike = {
  brand: "Yamaha",
  start: function() {
    console.log(this.brand);
  }
};

const startBike = bike.start;
startBike(); // undefined ‚Üí no left-of-dot

################
function Timer() { 
this.seconds = 0; 
setInterval(() => { this.seconds++; console.log(this.seconds); }, 1000); } 

new Timer();

‚úÖ Code
function Timer() {
  this.seconds = 0;

  setInterval(() => {
    this.seconds++;
    console.log(this.seconds);
  }, 1000);
}

new Timer();

‚úîÔ∏è First Key Point ‚Äî Constructor call with new

When you call:

new Timer();


JavaScript does the following internally:

Creates a new empty object
‚Üí {}

Sets this inside Timer() to that new object
‚Üí this = {} (the new Timer instance)

It adds the property:

this.seconds = 0;


So now the object is:

{ seconds: 0 }

‚úîÔ∏è Second Key Point ‚Äî Arrow function behavior

Arrow functions do NOT have their own this.

So in:

setInterval(() => {
  this.seconds++;
  console.log(this.seconds);
}, 1000);


The arrow function borrows this from the surrounding scope.

üëâ The surrounding scope = the Timer constructor function.

And inside the constructor, this refers to the Timer instance.

So inside the arrow function:

this.seconds means:
the seconds property of the Timer instance

This is why the seconds update works correctly.

‚úîÔ∏è Third Key Point ‚Äî What if you used a regular function?

If you wrote:

setInterval(function() {
  this.seconds++;
  console.log(this.seconds);
}, 1000);


Here, the callback is a regular function.

Regular functions get this from how they are called, not where they are created.

And setInterval() calls the callback without an object:

callback(); // no object to the left of .


So in a regular function:

this becomes the global object (window in browsers)

or undefined (in strict mode)

Thus:

this.seconds++   // ‚ùå would fail or modify window.seconds

‚úîÔ∏è Conclusion
Why does the arrow function work?

Because:

‚úî Arrow functions capture this from their parent scope
‚úî Parent scope = Timer constructor
‚úî Timer constructor's this = Timer instance

So the arrow function‚Äôs this ‚Üí the Timer object.

üéØ THE SIMPLEST SUMMARY

Arrow functions don‚Äôt have their own this.
They use the this of the place where they were created.

Here, the arrow function is created inside the constructor, so it inherits the constructor‚Äôs this ‚Üí the Timer instance.
